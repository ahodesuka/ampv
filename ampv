#!/usr/bin/env ruby19

require "gtk2"
require "fifo"
require "uri"

module Ampv

  PACKAGE = "ampv"

  ###################################
  # mpv Widget                      #
  ###################################
  class MPvWidget < Gtk::EventBox

    type_register
    signal_new("file_changed", GLib::Signal::RUN_FIRST, nil, nil, String)
    signal_new("length_changed", GLib::Signal::RUN_FIRST, nil, nil, Integer)
    signal_new("time_pos_changed", GLib::Signal::RUN_FIRST, nil, nil, Float)
    signal_new("stopped", GLib::Signal::RUN_FIRST, nil, nil)

    def initialize(args, scrobbler)
      if args.include?("--debug")
        args.delete("--debug")
        @debug = true
      end

      @scrobbler   = scrobbler
      @mpv_path    = "/usr/bin/mpv"
      @mpv_options = args.join(" ")
      @mpv_fifo    = "/tmp/mpv.fifo"

      super()

      @socket = Gtk::Socket.new
      @socket.modify_bg(Gtk::STATE_NORMAL, Gdk::Color.parse("#000"))

      @socket.signal_connect("plug_removed") { signal_emit("stopped"); true }
      add(@socket)
    end

    def start
      if @thread.nil?
        @fifo = Fifo.new(@mpv_fifo, :w, :nowait)

        cmd = "#{@mpv_path} \
          --identify \
          --idle \
          --input-file=#{@mpv_fifo} \
          --no-mouseinput \
          --msglevel=all=2 \
          --msglevel=global=4 \
          --wid=#{@socket.id} #{@mpv_options}"
        @thread = Thread.new { slave_reader(cmd) }
      end
    end

    def send(cmd)
      @fifo.puts(cmd) unless @fifo.nil?
    end

    def load_file(file, force_play=false)
      send("loadfile \"#{file}\"")
      @force_play = force_play
    end

    def play_pause
      send("cycle pause")
      @is_paused = @is_paused  ? false : true
    end

    def quit(watch_later)
      send("quit" + (watch_later ? "_watch_later" : ""))
      @thread.join unless @thread.nil? or not @thread.alive?
    end

  private
    def slave_reader(cmd)
      @pipe = IO.popen(cmd, "a+")

      until @pipe.nil? or @pipe.closed? or @pipe.eof?
        line = @pipe.readline.chomp
        if line.include?("ID_FILENAME=")
          signal_emit("file_changed", (@playing = line.rpartition("=").last))
          send("get_property pause") # saved position also saves play state

          @prog_thread.kill unless @prog_thread.nil? or not @prog_thread.alive?
          @prog_thread = Thread.new { progress_update }

          @scrobble_thread.kill unless @scrobble_thread.nil? or not @scrobble_thread.alive?
          @scrobble_thread = Thread.new { scrobble_update } unless @scrobbler.empty?
        elsif line.include?("ID_LENGTH=")
          signal_emit("length_changed", (@length = line.rpartition("=").last.to_i))
        elsif line.include?("ANS_pause=")
          @is_paused = line.rpartition("=").last == "yes"
          play_pause if @force_play and @is_paused
        elsif line.include?("ANS_time-pos=")
          signal_emit("time_pos_changed", line.rpartition("=").last.to_f)
        end

        if @debug or line.start_with?("Error")
          puts(line) unless line.include?("ANS_time-pos=") or
                            line.start_with?("ANS_ERROR") or
                            line.start_with?("Failed to get") or
                            line.start_with?("Command ")
        end
      end
    end

    def progress_update
      while true
        send("get_property time-pos") unless @is_paused
        sleep(1)
      end
    end

    def scrobble_update
      watched = 0
      while watched < @length * 0.5
        sleep(1)
        watched += 1 unless @is_paused
      end
      system("#{@scrobbler} \"#{@playing}\"")
    end

    def signal_do_file_changed(file) end
    def signal_do_length_changed(len) end
    def signal_do_time_pos_changed(pos) end
    def signal_do_stopped()
      @prog_thread.kill
      @scrobble_thread.kill unless @scrobble_thread.nil?
    end
  end

  ###################################
  # Progress Bar Widget             #
  ###################################
  class ProgressBarWidget < Gtk::DrawingArea
    def initialize(bar_color, head_color, height)
      super()
      modify_bg(Gtk::STATE_NORMAL, Gdk::Color.parse("#000"))
      set_height_request(height)

      signal_connect("expose_event") {
        @cx = window.create_cairo_context
        draw_widget
      }
      @value      = 0
      @bar_color  = bar_color
      @head_color = head_color
    end

    def draw_widget
      @cx.set_source_color(@bar_color)
      @cx.rectangle(0, 0, allocation.width * @value.to_f, allocation.height)
      @cx.fill

      if @value > 0
        @cx.set_source_color(@head_color)
        @cx.rectangle(allocation.width * @value.to_f, 0, 2, allocation.height)
        @cx.fill
      end
    end

    def value=(v)
      @value = v
      queue_draw
    end
  end

  ###################################
  # Playlist Window                 #
  ###################################
  class Playlist < Gtk::Window

    type_register
    signal_new("play_entry", GLib::Signal::RUN_FIRST, nil, nil, String)
    signal_new("playing_removed", GLib::Signal::RUN_FIRST, nil, nil)
    signal_new("open_file_chooser", GLib::Signal::RUN_FIRST, nil, nil)

    def initialize(x, y, w, h, is_visible)
      buttons = {
        [ Gtk::Stock::OPEN,    "Add to Playlist" ] => lambda { signal_emit("open_file_chooser") },
        [ Gtk::Stock::GO_UP,   "Move Up"         ] => lambda { move_selected_up                 },
        [ Gtk::Stock::GO_DOWN, "Move Down"       ] => lambda { move_selected_down               },
        [ Gtk::Stock::REMOVE,  "Remove Selected" ] => lambda { remove_selected                  },
        [ Gtk::Stock::CLEAR,   "Clear Playlist"  ] => lambda { clear                            }
      }

      super()
      set_title("Playlist - #{PACKAGE}")
      set_default_size(w, h)
      set_skip_taskbar_hint(true)
      move(x, y)

      Gtk::Drag.dest_set(self, Gtk::Drag::DEST_DEFAULT_ALL,
                         [ [ "text/uri-list", 0, 0 ] ],
                         Gdk::DragContext::ACTION_LINK)

      signal_connect("show") { move(@pos[0], @pos[1]) unless @pos.nil? }
      signal_connect("hide") { @pos = window.root_origin }
      signal_connect("delete_event") { hide_on_delete }

      signal_connect("key_press_event") { |_w, e|
        hide_on_delete if e.keyval == Gdk::Keyval::GDK_Escape
      }

      vbox = Gtk::VBox.new(false, 10)
      vbox.border_width = 10
      add(vbox)

      sw = Gtk::ScrolledWindow.new
      sw.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC)
      vbox.pack_start(sw)

      @model    = Gtk::ListStore.new(String, String)
      @treeview = Gtk::TreeView.new(@model)
      @treeview.enable_search  = false
      @treeview.rubber_banding = true
      @treeview.reorderable = true
      @treeview.selection.mode = Gtk::SELECTION_MULTIPLE

      @treeview.signal_connect("row_activated") { |_w, p, c|
        signal_emit("play_entry", @model.get_iter(p)[0])
      }
      @treeview.signal_connect("key_press_event") { |_w, e|
        remove_selected if e.keyval == Gdk::Keyval::GDK_Delete
      }
      @treeview.signal_connect("button_press_event") { |_w, e|
        @menu.popup(nil, nil, e.button, e.time) if
          e.event_type == Gdk::Event::BUTTON_PRESS and e.button == 3
      }

      ["Name", "Length"].each_with_index { |_x, i|
        renderer = Gtk::CellRendererText.new
        column   = Gtk::TreeViewColumn.new(_x,
                                           renderer,
                                           :text => i)
        if _x == "Name"
          renderer.ellipsize = Pango::ELLIPSIZE_MIDDLE
          column.expand = true
          column.set_cell_data_func(renderer) { |t, c, m, j|
            c.text = File.basename(m.get_value(j, 0)) unless m.get_value(j, 0).nil?
          }
        end

        @treeview.append_column(column)
      }

      sw.add(@treeview)

      hbox = Gtk::HBox.new(true, 5)

      buttons.each { |k, v|
        button = Gtk::Button.new
        button.image = Gtk::Image.new(k[0], Gtk::IconSize::BUTTON)
        button.height_request = 36
        button.set_tooltip_text(k[1])
        button.signal_connect("clicked") { v.call }
        hbox.pack_start(button)
      }

      vbox.pack_start(hbox, false)

      @menu = Gtk::Menu.new
      buttons.each { |k, v|
        item = Gtk::ImageMenuItem.new(k[1])
        item.image = Gtk::Image.new(k[0], Gtk::IconSize::MENU)
        item.signal_connect("activate") { v.call }
        @menu.append(item)
      }
      @menu.show_all

      show_all if is_visible
    end

    def count
      i = 0
      @model.each { i += 1 }
      return i
    end

    def add_file(file)
      contains = false
      @model.each { |m, p, iter|
        if iter[0] == file
          contains = true
          break
        end
      }
      unless contains
        iter = @model.append
        iter[0] = file
      end
    end

    def move_selected_up
      @treeview.selection.selected_rows.each { |path|
        tmp = path.dup
        break if not tmp.prev! or @treeview.selection.selected_rows.include?(tmp)
        @model.move_before(@model.get_iter(path), @model.get_iter(tmp))
      }
    end

    def move_selected_down
      @treeview.selection.selected_rows.reverse.each { |path|
        break if @treeview.selection.selected_rows.include?((tmp = path.dup.next!))
        tmp = @model.get_iter(tmp)
        @model.move_after(@model.get_iter(path), tmp) unless tmp.nil?
      }
    end

    def remove_selected
      to_remove = [ ]
      @treeview.selection.selected_rows.each { |path|
        to_remove.push(@model.get_iter(path))
      }
      to_remove.each { |iter|
        signal_emit("playing_removed") if iter[0] == @playing
        @model.remove(iter)
      }
    end

    def get_next
      @model.each { |m, p, iter|
        return iter.next! ? iter[0] : nil if iter[0] == @playing
      }
    end

    def get_prev
      prev = nil
      @model.each { |m, p, iter|
        return prev if iter[0] == @playing
        prev = iter[0]
      }
    end

    def get_entries
      entries = [ ]
      @model.each { |m, p, iter| entries.push(iter[0]) }
      return entries
    end

    def clear
      @model.clear
      signal_emit("playing_removed")
    end

    def set_selected(file)
      @playing = file
      i = 0
      @model.each { |m, p, iter|
        if iter[0] == @playing
          @treeview.set_cursor(Gtk::TreePath.new(i), nil, false)
          break
        end
        i += 1
      }
    end

    def update_length(length)
      @model.each { |m, p, iter|
        if iter[0] == @playing
          iter[1] = Time.at(length).utc.strftime("%H:%M:%S") unless length == 0
          break
        end
      }
    end

  private
    def signal_do_play_entry(file) end
    def signal_do_playing_removed() end
    def signal_do_open_file_chooser() end
  end

  ###################################
  # ampv Window                     #
  ###################################
  class Ampv < Gtk::Window

    MAIN_CONF  = "#{ENV["HOME"]}/.config/ampv.conf"
    INPUT_CONF = "#{ENV["HOME"]}/.mpv/input.conf"
    VIDEO_EXTS = [ ".avi", ".mkv", ".mp4", ".mpeg", ".mpg", ".ogm" ]
    KEY_NAMES  = {
      "esc"         => "Escape",
      "space"       => "space",
      "right"       => "Right",
      "left"        => "Left",
      "up"          => "Up",
      "down"        => "Down",
      "pgup"        => "Page_Up",
      "pgdwn"       => "Page_Down",
      "home"        => "Home",
      "end"         => "End",
      "ins"         => "Insert",
      "del"         => "Delete",
    }
    WHEEL_BUTTONS = {
      Gdk::EventScroll::UP    => 4,
      Gdk::EventScroll::DOWN  => 5,
      Gdk::EventScroll::LEFT  => 6,
      Gdk::EventScroll::RIGHT => 7
    }

    def initialize
      load_config
      super
      set_title(PACKAGE)
      set_default_size(@config["width"], @config["height"])
      set_window_position(Gtk::Window::POS_CENTER)
      move(@config["x"], @config["y"]) unless @config["x"] == -1 and @config["y"] == -1

      Gtk::Drag.dest_set(self, Gtk::Drag::DEST_DEFAULT_ALL,
                         [ [ "text/uri-list", 0, 0 ] ],
                         Gdk::DragContext::ACTION_LINK)

      signal_connect("delete_event") { quit }
      signal_connect("scroll_event") { |w, e| handle_mouse_event(e) }
      signal_connect("button_press_event") { |w, e| handle_mouse_event(e) }
      signal_connect("key_press_event") { |w, e| handle_keyboard_event(e) }
      signal_connect("drag_data_received") { |w, dc, x, y, sd, type, time|
        handle_drop_event(sd.data, dc, time, false, false)
      }

      vbox = Gtk::VBox.new
      add(vbox)

      args = process_args
      load_bindings

      @mpv = MPvWidget.new(args, @config["scrobbler"])
      @mpv.signal_connect("file_changed") { |w, file|
        @playing = file
        @mpv.send("show_text ${media-title} 1500") if window.state.fullscreen?
        @playlist.set_selected(@playing)
        set_title(File.basename(@playing))
      }
      @mpv.signal_connect("length_changed") { |w, len|
        @length = len
        @playlist.update_length(@length)
      }
      @mpv.signal_connect("time_pos_changed") { |w, pos| @progress_bar.value = pos / @length.to_f }
      @mpv.signal_connect("stopped") {
        @progress_bar.value = 0
        if @really_stop
          set_title(PACKAGE)
          @really_stop = false
        else
          load_file(@playlist.get_next, false)
        end
      }
      vbox.pack_start(@mpv)

      @playlist = Playlist.new(@config["playlist_x"],
                               @config["playlist_y"],
                               @config["playlist_width"],
                               @config["playlist_height"],
                               @config["playlist_visible"])
      @playlist.signal_connect("open_file_chooser") { open_file_chooser }
      @playlist.signal_connect("drag_data_received") { |w, dc, x, y, sd, type, time|
        handle_drop_event(sd.data, dc, time)
      }
      @playlist.signal_connect("play_entry") { |w, file| load_file(file, false, false, false, true) }
      @playlist.signal_connect("playing_removed") { @mpv.send("stop"); @really_stop = true }

      @progress_bar = ProgressBarWidget.new(@config["bar_color"],
                                            @config["head_color"],
                                            @config["progress_bar_height"])
      @progress_bar.add_events(Gdk::Event::BUTTON_PRESS_MASK)
      @progress_bar.signal_connect("button_press_event") { |w, e| handle_seek_event(e) }
      vbox.pack_start(@progress_bar, false, false)

      show_all
      @mpv.start

      argv = ARGV.join(" ")
      if not argv.empty?
        load_file(argv)
      elsif not @config["playlist"].empty?
        @config["playlist"].each { |x| load_file(x, true, true, false) }
        @playlist.set_selected(@config["playlist_selected"])
      end
    end

    def load_config
      @config = {
        "width"                  => Gdk::Screen.default.width > 1280 ? 1280 : 853,
        "height"                 => Gdk::Screen.default.width > 1280 ? 726  : 486,
        "x"                      => -1,
        "y"                      => -1,
        "fullscreen_progressbar" => false,
        "progress_bar_visible"   => true,
        "progress_bar_height"    => 6,
        "bar_color"              => "#8f5b5b",
        "head_color"             => "#c48181",
        "playlist_width"         => 360,
        "playlist_height"        => 550,
        "playlist_x"             => 0,
        "playlist_y"             => 0,
        "playlist_visible"       => true,
        "always_save_position"   => false,
        "scrobbler"              => "",
        "playlist_selected"      => "",
        "playlist"               => [ ],
      }

      if File.exists?(MAIN_CONF)
        File.readlines(MAIN_CONF).each { |line|
          key, _, val = line.partition("=")
          next unless @config.has_key?(key) and not key.start_with?("#")

          val = val.strip

          if @config[key].is_a?(Integer)
            val = val.to_i
          elsif @config[key].is_a?(TrueClass) or @config[key].is_a?(FalseClass)
            val = val == "true"
          elsif @config[key].is_a?(Array)
            val = val.split("|")
          elsif val.start_with?("#")
            begin
              c = Gdk::Color.parse(val)
            rescue
              puts("Invalid hexidecimal color for setting `#{key}': `#{val}")
              c = Gdk::Color.parse(@config[key])
            end
            val = c
          end

          @config[key] = val
        }
      end
    end

    def process_args
      args = [ ]
      ARGV.dup.each { |arg|
        if arg.start_with?("-")
          args.push(arg)
          ARGV.delete(arg)
        end
      }
      return args
    end

    def load_bindings
      @mouse_bindings = [ ]
      @key_bindings   = [ ]
      if File.exists?(INPUT_CONF)
        File.readlines(INPUT_CONF).each { |line|
          line = line.strip
          if line.start_with?("MOUSE_BTN")
            # 4 = up, 5 = down, 6 = left, 7 = right
            button, cmd = line.match(/MOUSE_BTN(\d+)(?:_DBL)?\s+(.+)$/).captures
            button = button.to_i + 1
            type   = (4..7).include?(button) ? Gdk::Event::SCROLL :
              line.include?("DBL") ? Gdk::Event::BUTTON2_PRESS : Gdk::Event::BUTTON_PRESS
            @mouse_bindings[type] = [ ] if @mouse_bindings[type].nil?
            @mouse_bindings[type][button] = cmd
          elsif not line.empty?
            key, cmd = line.match(/^([^\s]+)\s+(.+)$/).captures
            if name = KEY_NAMES[key.downcase]
              keyval = Gdk::Keyval.from_name(name)
            else
              keyval = Gdk::Keyval.from_name(key)
            end

            @key_bindings[keyval] = cmd if keyval > 0
          end
        }
      end
    end

    def load_file(file, add_to_playlist=true, do_not_play=false, auto_add=true, force_play=false)
      return if file.nil? or file.empty? or
        not VIDEO_EXTS.include?(File.extname(file).downcase)

      if add_to_playlist
        if @playlist.count == 0 and auto_add
          dir     = File.dirname(file)
          entries = Dir.entries(dir).sort
          entries.delete_if { |x| x.start_with?(".") or not VIDEO_EXTS.include?(File.extname(x)) }
          entries.map { |x|
            x = dir + "/" + x
            @playlist.add_file(x)
          }
        else
          @playlist.add_file(file)
        end
      end

      @mpv.load_file(file, force_play) unless do_not_play
    end

    def handle_mouse_event(e)
      button = e.event_type == Gdk::Event::SCROLL ? WHEEL_BUTTONS[e.direction] : e.button
      return if @mouse_bindings[e.event_type].nil?

      process_cmd(@mouse_bindings[e.event_type][button])

      return true
    end

    def handle_keyboard_event(e)
      process_cmd(@key_bindings[e.keyval])

      return true
    end

    def handle_seek_event(e)
      if e.event_type == Gdk::Event::BUTTON_PRESS and e.button == 1
        pos = e.x / allocation.width * @length.to_f
        seek("seek #{pos} absolute")
      end

      return true
    end

    def handle_drop_event(data, context, time, do_not_play=false, replace=false)
      files = URI.decode(data).gsub("file://", "").split("\r\n")
      @playlist.clear if replace

      files.each { |x|
        load_file(x, true, do_not_play)
      }

      Gtk::Drag.finish(context, true, true, time)
    end

    def process_cmd(cmd)
      case cmd
      when "cycle fullscreen"
        toggle_fullscreen
      when "cycle pause"
        @mpv.play_pause
      when "cycle playlist"
        @playlist.visible? ? @playlist.hide : @playlist.show
      when /seek /
        seek(cmd)
      when /add chapter/
        seek(cmd)
      when "playlist_next"
        load_file(@playlist.get_next, false)
      when "playlist_prev"
        load_file(@playlist.get_prev, false)
      when "open_file_chooser"
        open_file_chooser
      when "cycle progress_bar"
        toggle_progress_bar
      when "quit_watch_later"
        quit(true)
      when "quit"
        quit
      else
        @mpv.send(cmd) if cmd
      end
    end

    def seek(cmd)
      cmd = "no-osd " + cmd unless cmd.start_with?("no-osd") or
                               not @progress_bar.visible?
      @mpv.send(cmd)
      @mpv.send("get_property time-pos")
    end

    def toggle_fullscreen
      if window.state.fullscreen?
        @progress_bar.set_height_request(@config["progress_bar_height"]) if @progress_bar.visible?
        unfullscreen
      else
        @progress_bar.set_height_request(0) unless @config["fullscreen_progressbar"] or
                                            not @progress_bar.visible?
        fullscreen
      end
    end

    def toggle_progress_bar
      if @progress_bar.visible?
        @progress_bar.hide
      else
        @progress_bar.show
      end
    end

    def open_file_chooser
      dialog = Gtk::FileChooserDialog.new("Open File - #{PACKAGE}",
                                          self, Gtk::FileChooser::ACTION_OPEN, nil,
                                          [ Gtk::Stock::CANCEL, Gtk::Dialog::RESPONSE_CANCEL ],
                                          [ Gtk::Stock::OPEN,   Gtk::Dialog::RESPONSE_ACCEPT ])
      dialog.select_multiple = true
      do_not_play = @playlist.count > 0

      filter = Gtk::FileFilter.new
      filter.name = "Video Files"
      VIDEO_EXTS.each { |x| filter.add_pattern("*#{x}") }

      dialog.add_filter(filter)
      dialog.filenames.each { |x|
        load_file(x, true, do_not_play)
        do_not_play = true
      } if dialog.run == Gtk::Dialog::RESPONSE_ACCEPT
      dialog.destroy
    end

    def quit(watch_later=false)
      @config["x"],
      @config["y"],
      @config["width"],
      @config["height"]               = window.geometry unless window.state.fullscreen?
      @config["playlist_x"],
      @config["playlist_y"],
      @config["playlist_width"],
      @config["playlist_height"]      = @playlist.window.geometry
      @config["playlist_visible"]     = @playlist.visible?
      @config["playlist_selected"]    = @playing
      @config["playlist"]             = @playlist.get_entries.join("|")
      @config["progress_bar_visible"] = @progress_bar.visible?
      File.open(MAIN_CONF, "w") { |file| @config.each { |k, v| file.puts("#{k}=#{v}") } }

      @mpv.quit(@config["always_save_position"] ? true : watch_later)
      Gtk.main_quit
    end
  end
end

Ampv::Ampv.new
Gtk.main

